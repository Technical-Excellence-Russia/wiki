# Порядок преобразований (TPP, the) [draft]

Оригинальный текст из статьи Робертом Мартина [The Transformation Priority Premise](https://blog.cleancoder.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html).

## Порядок преобразований (The Transformation Priority Premise)

19 Декабря 2010 года

Это статья предлагает довольно радикальный подход. Она подразумевает, что "[рефакторинг](Refactoring.md)" может подразумевать "_преобразования_". Если [рефакторинг](Refactoring.md) это набор простых операций, которые меняют структуру кода без изменения поведения, то _преобразования_ - поведение меняют. Они могут быть использованы, как единственный путь для исправления упавших тестов в [red/green/refactor](TDD.md) цикле. _Преобразования_ имеют приоритет или предпочтительный порядок, который может предотвратить тупиковые ситуации или длительные задержки в [red/green/refactor](TDD.md) цикле, если ему следовать при упорядочивании тестов.

> "В то время, как тесты становятся более конкретным, то код - более общим."

Недавно эта мантра обрела для меня новое значение.

Я изобрел её, как правило, чтобы уберечь своих студентов от приобретения отвратительной привычки писать код, который копирует тесты во время циклов [TDD](TDD.md):

````java
@Test
public void primeFactorsOfFour() {
  assertEquals(asList(),    PrimeFactors.of(1));
  assertEquals(asList(2),   PrimeFactors.of(2));
  assertEquals(asList(3),   PrimeFactors.of(3));
  assertEquals(asList(2,2), PrimeFactors.of(4));
  ...
}

public class PrimeFactors {
  public static of(int n) {
    if (n == 1)
      return asList();
    else if (n == 2)
      return asList(2);
    else if (n == 3)
      return asList(3);
    else if (n == 4)
      return asList(2,2);
    ...
````

Новички в [TDD](TDD.md) часто задаются вопросом, почему [TDD](TDD.md) не приводит if-else коду. Я обычно указываю на правило выше. Такой ответ удовлетворяет студентов, особенно когда я иллюстрирую эту идею [катой](CodingDojoKata.md) по написанию кода для поиска простых множителей целого числа (англ. Prime Factors Kata).

### Факторизация целых чисел

Я придумал эту [кату](CodingDojoKata.md) 10 лет назад, когда мой сын Джастин делал домашнее задание. Он должен был найти простые множители для нескольких целых чисел (выполнить факторизацию). Сказал ему, что его ответы будет проверять программа, которую я напишу. Предполагалось, что он должен был вводить свой вариант ответа, а программа проверяла бы, верен он или нет.

Разместившись за кухонным столом, я приступил к написанию алгоритма на Ruby, использую новых подход [TDD](TDD.md). Это было одно из тех событий, которые позволили посмотреть на некоторые вещи по-новому. При переходе от теста к тесту алгоритм строился совершенно неожиданным путем. Я был поражен тем, что смог сделать кейс с параметром 3 зелеными, поменяв только 1 символ в коде с ```2``` на ```n```. Мое волнение усилилось, когда кейс с параметром 8 стал зеленым, сменив всего лишь ключевое слово ```if``` на ```while```. Я чувствовал в этом что-то такое, что не мог точно описать. Но думаю, что теперь могу.

### "Тупость"

В течение следующих нескольких лет я написал множество тестов. Более того, тренировался на сотни раз на [катах](CodingDojoKata.md). Время от времени я вношу небольшие улучшения в эту [кату](CodingDojoKata.md): улучшаю тест и код, делая их логичнее, проще и элегантнее. После стольких тренировок и улучшений я начал кое-что замечать. И это связано с другой претензией к [TDD](TDD.md): _тупость_.

Другая [ката](CodingDojoKata.md) "Боулинг" (англ. Bowling Game Kata) начинается c теста, когда шар попадает в желоб, т.е. не сбивает ни одной кегли:

````java
@Test
public void gutterGame() {
  for (int i=0; i<20; i++)
    game.roll(0);
  assertEquals(0, game.score());
}
````

Во время обучения TDD я спрашиваю: "Что мы должны сделать, чтобы такой тест прошел?". Новички часто теряются от такого вопроса, ожидаю что мы будем писать алгоритм для расчета очков в боулинге. Но мы удивляем их ещё больше, делая тест зеленым следующим способом:

````java
public int score() {
  return 0;
}
````

В этот момент разработчики стонут и закатывают глаза. Они абсолютно убеждены в том, что это тупо, и их заставляют писать _неправильный код_.

Раньше соглашался, что это было глупо. И что мы просто откладывали принятие решений до тех пор, пока у нас не будет больше информации. Также, что это хороший способ проверить тесты - поскольку, возвращая ноль, мы можем ясно видеть, что тест пройден и, следовательно, правильный.

### Последовательность преобразований

Но что я начал осознавать, что возвращать ноль - _это не так тупо, как это может выглядеть_. Нет, если это делать в рамках соответствующего контекста.

При использовании [TDD](TDD.md) наш рабочий код проходит через последовательность преобразований. Раньше я думал, что это преобразование из глупого в интеллектуальное. Но я начал понимать, что это совсем не так. Скорее, код проходит через последовательность преобразований _от конкретного к более общему_.

Возвращать ноль из функции ```score``` - это частный случай. Но он представлен в правильной форме. Это целое число, и оно имеет нужное значение. Следовательно, _форма_ алгоритма верна, просто она еще не была обобщена.

Следующий тест для "Боулинга": 

````java
@Test
public void allOnes() {
  for (int i=0; i<20; i++)
    game.roll(1);
  assertEquals(20, game.score());
}
````

Чтобы сделать его зеленым, мы добавляем суммирование всех переданных значений в метод ```roll``` в переменной ```score```. Далее меняем метода ```score```, чтобы возвращать это значение:

````java
public int score() {
    return score;
}
````

Заметьте, что мы преобразовали константу ```0``` в переменную ```score```. Алгоритм имеет ту же форму (так же возвращает ```int```), но теперь имеет более общую реализацию. Почему она более общая? Потому, что переменная - это _обобщение константы_.

Другими словами, произошедшая трансформация - это простое изменение некоторой части решения из более конкретной формы в более общую!

Раньше я думал, что это просто интересно. Меня поражал тот факт, что иногда можно было выполнять такие простые преобразования из конкретного в обобщенное. В последнее время я начал подозревать, что это некое правило, т.е. каждое изменение в коде является либо изменением поведения преобразования из специфического в обобщенное, либо [рефакторингом](Refactoring.md). Действительно, я думаю, что это правило может стать руководством в выборе следующего теста и каким образом должен быть реализован код, чтобы сделать этот тест зеленым.

Но не будем забегать вперёд. Какой же следующий тест для "Боулинга"?

````java
@Test
public void oneSpare() {
    game.roll(5);
    game.roll(5); // spare
    game.roll(3);
    rollMany(20,0);
    assertEquals(16, g.score());
}
````

Этот тест заставляет нас забыть о простой реализации метода ```score``` в пользу более сложной. Переменная ```score```, значение которой обновлялась в методе ```roll```, теперь уступила место массиву бросков

Опять мы привели конкретную реализацию (переменную, которая хранила рассчитанное значение) к более общей форме - циклу, считающему очки из массива.

Другое общее преобразование может быть найдено в [кате](CodingDojoKata.md) "Факторизация" (с неё началась статья). Чтобы выполнить второе условие, мы вставляем конструкцию ```if```. Код превращается из

````java
List factors = new ArrayList();
return factors;
````

в

````java
List factors = new ArrayList();
if (n>1)
factors.add(2);
return factors;
````

В этом случае мы сделали код более общим, разбив порядок выполнения на две ветки с помощью условного оператора. Первая ветка позволяет пройти старым тестам, новая - новому.

[Ката](CodingDojoKata.md) "Факторизация" интересна тем, что преобразование происходит опять в кейсе с 4, когда добавляется условный оператор ```if```, чтобы обрабатывать случаи, когда параметр делится на 2 без остатка:

````java
List factors = new ArrayList();
if (n>1) {
  if (n % 2 == 0) {
    factors.add(2);
    n %= 2;
  }
  if (n > 1)
    factors.add(n);
}
return factors;
````

Новая ветка покрывает кейс с параметром 4, определяя, что 4 делится на 2. После деления добавляем 2 к массиву множителей, а частное становиться новым параметром, позволяя переиспользовать эту ветку.

Еще более интересен кейс с параметром 8, когда внутренний ```if``` преобразуется в ```while```. После этого для кейса с параметром 9 преобразуем внешний ```if``` также в ```while```. Совершенно очевидно, что ```while``` - обобщенная форма ```if```.

### Преобразования

Что же такое преобразования? Возможно, мы можем представить их список:
* **({}–>nil)** no code at all->code that employs nil
* **(nil->constant)**
* **(constant->constant+)** простая константа в более сложную
* **(constant->scalar)** переменная или аргумент метода вместо константы
* **(statement->statements)** больше безусловных выражений
* **(unconditional->if)** деление потока выполнения
* **(scalar->array)**
* **(array->container)**
* **(statement->recursion)**
* **(if->while)**
* **(expression->function)** метод вместо выражения
* **(variable->assignment)** замена значения переменной

Скорее всего есть и другие.

Возможно, вы заметили сходство этих преобразований с [рефакторингом](Refactoring.md). Однако, [рефакторинг](Refactoring.md) используются для преобразования _структуры_ кода без изменения его поведения. Эти преобразования используются для изменения _поведения_ кода. В частности, мы используем эти преобразования, чтобы заставить новые тесты пройти.

Очевидно, что каждое из преобразований имеет цель. Все они преобразуют поведение кода из чего-то конкретного в что-то более общее. В некоторых случаях это константа, преобразуемая в переменную, или переменная, преобразуемая в массив. В других случаях это оператор ```if```, преобразуемый в цикл ```while```, или простая последовательность, преобразуемая в рекурсию.

Также должно быть ясно, что я _примерно_ упорядочил преобразования по их сложности. То есть преобразования в верхней части списка проще и менее рискованны, чем преобразования, которые находятся ниже.

### The Priority Premise

Адаптировал: [Кротов Артём](https://github.com/timmson).

Остались вопросы? Задавай в [нашем чате](https://t.me/technicalexcellenceru).
